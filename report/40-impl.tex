\chapter{Технологический раздел}
\label{cha:impl}

\section{Выбор языка и среды программирования}

В качестве языка программирования был выбран язык Си. Для сборки модуля использовалась утилита make. В качестве среды программирования был выбран VSCode.

\section{Реализация алгоритма создания символьного устройства}

В листинге \ref{code:init} приведена реализация алгоритма создания символьного устройства.

\begin{lstlisting}[label=code:init,caption=Реализация алгоритма создания символьного устройства]
error = alloc_chrdev_region(&devt, 0, 1, "usb15");

if (error < 0)
{
	remove_proc_entry(PROC_FILE_NAME_HIDDEN, NULL);
	remove_proc_entry(PROC_FILE_NAME_PROTECTED, NULL);
	return error;
}

major = MAJOR(devt);
minor = MINOR(devt);

fake_class = class_create(THIS_MODULE, "custom_char_class");

if (IS_ERR(fake_class)) {
	remove_proc_entry(PROC_FILE_NAME_HIDDEN, NULL);
	remove_proc_entry(PROC_FILE_NAME_PROTECTED, NULL);
	unregister_chrdev_region(MKDEV(major, minor), 1);
	return PTR_ERR(fake_class);
}

cdev_init(&fake_cdev, &fake_fops);
fake_cdev.owner = THIS_MODULE;
cdev_add(&fake_cdev, devt, 1);

fake_device = device_create(fake_class,
	NULL,   /* no parent device */
	devt,    /* associated dev_t */
	NULL,   /* no additional data */
	"usb15");  /* device name */

if (IS_ERR(fake_device))
{
	remove_proc_entry(PROC_FILE_NAME_HIDDEN, NULL);
	remove_proc_entry(PROC_FILE_NAME_PROTECTED, NULL);
	class_destroy(fake_class);
	unregister_chrdev_region(devt, 1);
	return -1;
}
\end{lstlisting}

\section{Реализация алгоритма проверки наличия разрешения на модификацию файла}

Реализация алгоритма проверки наличия разрешения на модификацию файла представлена в листинге \ref{code:func}.

\begin{lstlisting}[label=code:func,caption=Реализация алгоритма проверки наличия разрешения на модификацию файла]
int check_fs_blocklist(char *input)
{
	int i = 0;
	
	if (fs_protect==0)
	{
		return 0;
	}
	
	if (strlen(protected_files[0]) <= 2)
	{
		return 0;
	}
	
	while (i != protected_index)
	{
		if(strstr(input, protected_files[i]) != NULL)
		return 1;
		i++;
	}
	
	return 0;
}

int check_fs_hidelist(char *input)
{
	int i = 0;
	if (fs_hidden == 0)
	{
		return 0;
	}
	
	if (strlen(hidden_files[0]) <= 2)
	{
		return 0;
	}
	
	while (i != hidden_index)
	{
		if(strstr(input, hidden_files[i]) != NULL)
		return 1;
		i++;
	}
	
	return 0;
}
\end{lstlisting}

\section{Инициализация полей структуры ftrace\_hook}

Инициализация полей структуры ftrace\_hook представлена в листинге~\ref{code:ftracehook2}.

\begin{lstlisting}[label=code:ftracehook2,caption=Инициализация полей структуры ftrace\_hook]
	static struct ftrace_hook demo_hooks[] = {
		HOOK("sys_write", fh_sys_write, &real_sys_write),
		HOOK("sys_openat", fh_sys_open, &real_sys_open),
		HOOK("sys_unlinkat", fh_sys_unlinkat, &real_sys_unlinkat),
		HOOK("sys_getdents64", fh_sys_getdents64, &real_sys_getdents64)
	};
\end{lstlisting}


