\chapter{Аналитический раздел}
\label{cha:analysis}

\section{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуль ядра для ОС Linux, позволяющий скрывать файлы или запрещать их изменение, чтение и удаление. Предусмотреть возможность ввода пароля для отображения файлов или разрешения операций над ними. Предоставить пользователю возможность задавать список таких файлов.

Для решения поставленной задачи необходимо:

\begin{itemize}
	\item проанализировать возможности перехвата функций ядра Linux;
	\item выбрать системные вызовы, которые необходимо перехватить;
	\item разработать алгоритм перехвата, алгоритмы hook--функций и структуру программного обеспечения;
	\item реализовать программное обеспечение;
	\item исследовать работу ПО.
\end{itemize}

\section{Способы перехвата функций ядра}

\subsection{ftrace}

ftrace предоставляет возможности для трассировки функций.  С его помощью можно отслеживать контекстные переключения, измерять время обработки прерываний, высчитывать время на активизацию заданий с высоким приоритетом и многое другое \cite{ftrace}.

Ftrace был разработан Стивеном Ростедтом и добавлен в ядро в 2008 году, начиная с версии 2.6.27. Ftrace --- фреймворк, предоставляющий отладочный кольцевой буфер для записи данных. Собирают эти данные встроенные в ядро программы--трассировщики \cite{ftrace}.

Работает ftrace на базе файловой системы debugfs, которая в большинстве современных дистрибутивов Linux смонтирована по умолчанию. 

Каждую перехватываемую функцию можно описать следующей структурой:

\begin{lstlisting}[label=code:ftracehook,caption=Структура ftrace\_hook]
	struct ftrace_hook {
		const char *name;
		void *function;
		void *original;
		
		unsigned long address;
		struct ftrace_ops ops;
	};
\end{lstlisting}

Поля структуры:

\textit{name} --- имя перехватываемой функции;

\textit{function} ---  адрес функции--обертки, которая будет вызываться вместо перехваченной функции;

\textit{original} ---  указатель на место, куда следует записать адрес перехватываемой функции, заполняется при установке;

\textit{address} --- адрес перехватываемой функции, заполняется при установке;

\textit{ops} --- служебная информация ftrace.

\begin{lstlisting}[label=code:ftracehookexm,caption=Пример заполнения структуры ftrace\_hook]
	#define HOOK(_name, _function, _original)       \
	{                                       \
		.name = (_name),                    \
		.function = (_function),            \
		.original = (_original),            \
	}
	
	static struct ftrace_hook hooked_functions[] = {
		HOOK("sys_clone",   fh_sys_clone,   &real_sys_clone),
		HOOK("sys_execve",  fh_sys_execve,  &real_sys_execve),
	};
\end{lstlisting}

\subsection{kprobes}

Kprobes --- специализированное API, в первую очередь предназначенное для отладки и трассирования ядра. Этот интерфейс позволяет устанавливать пред- и постобработчики для любой инструкции в ядре, а также обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут их изменять.

Kprobes реализуются с помощью точек останова (инструкции int3), внедряемых в исполнимый код ядра, что позволяет устанавливать kprobes в любом месте любой функции, если оно известно. Аналогично, kretprobes реализуются через подмену адреса возврата на стеке и позволяют перехватить возврат из любой функции.

При использовании kprobes для получения аргументов функции или значений локальных переменных надо знать, в каких регистрах или где на стеке они лежат, и самостоятельно их оттуда извлекать. Для решения данной проблемы существует jprobes ---  надстройка над kprobes, самостоятельно извлекающая аргументы функции из регистров или стека и вызывающая обработчик, который должен иметь ту же сигнатуру, что и перехватываемая функция. Однако jprobes объявлен устаревшим и удален из современных ядер.

\subsection{ Linux Security API}

Linux Security API --- интерфейс, созданный для перехвата функций ядра. В критических местах кода ядра расположены вызовы security--функций, которые в свою очередь вызывают коллбеки, установленные security--модулем. Security--модуль может анализировать контекст операции и принимать решение о ее разрешении или запрете.

Для Linux Security API характерны следующие ограничения:
\begin{itemize}
	\item security--модули не могут быть загружены динамически, они являются частью ядра и требуют его перекомпиляции;
	\item в системе может быть только один security--модуль.
\end{itemize}

%Если по поводу множественности модулей позиция разработчиков ядра неоднозначная, то запрет на динамическую загрузку принципиальный: security-модуль должен быть частью ядра, чтобы обеспечивать безопасность постоянно, с момента загрузки.

Таким образом, для использования Security API необходимо поставлять собственную сборку ядра, а также интегрировать дополнительный модуль с SELinux или AppArmor, которые используются популярными дистрибутивами. 

\subsection{Модификация таблицы системных вызовов}

В ядре Linux все обработчики системных вызовов хранятся в таблице sys\_call\_table \cite{linux}. Подмена значений в этой таблице приводит к смене поведения всей системы. Таким образом, сохранив старое значения обработчика и подставив в таблицу собственный обработчик, можно перехватить системный вызов.

Однако данный подход обладает следующими недостатками:
\begin{itemize}
	\item Техническая сложность реализации, заключающаяся в необходимости обхода защиты от модификации таблицы, атомарное и безопасное выполнение замены.
	\item Невозможность перехвата некоторых обработчиков. В ядрах до версии 4.16 обработка системных вызовов для архитектуры x86\_64 содержала целый ряд оптимизаций. Некоторые из них требовали того, что обработчик системного вызова являлся специальным переходником, реализованным на ассемблере. Соответственно, подобные обработчики порой сложно, а иногда и вовсе невозможно заменить на собственные, написанные на Си \cite{all}.
\end{itemize}

\subsection{Cплайсинг}

Сплайсинг заключается в замене инструкций в начале функции на безусловный переход, ведущий в обработчик. Оригинальные инструкции переносятся в другое место и исполняются перед переходом обратно в перехваченную функцию. Именно таким образом реализуется jump--оптимизация для kprobes. Используя сплайсинг, можно добиться тех же результатов, но без дополнительных расходов на kprobes и с полным контролем ситуации.

Сложность использования сплайсинга заключается в необходимости синхронизации установки и снятия перехвата, обхода защиты от модификации регионов памяти с кодом, инвалидации кешей процессора после замены инструкций, дизассемблировании заменяемых инструкций и проверки на отсутствие переходов внутрь заменяемого кода.


%\section{Перехват функций ядра с помощью ptrace}

%ptrace() --- это системный вызов, который дает возможность одному процессу управлять исполнением другого. Он так же позволяет изменять содержимое памяти трассируемого процесса. Трассируемый процесс ведет себя как обычно до тех пор пока не получит сигнал. Когда это происходит, процесс переходит в состояние останова, а процесс--трассировщик информируется об этом вызовом wait(). После этого процесс--трассировщик, через вызовы ptrace, определяет реакцию трассируемого процесса. Исключение составляет сигнал SIGKILL, который уничтожает процесс.

%Кроме того, можно задать переход трассируемого процесса в состояние останова по определенному событию, которое возникло в ходе его исполнения. Это происходит только в том случае, если процесс--трассировщик установил какие--либо флаги событий в контексте трассируемого процесса. Трассировщик также может завершить трассируемый процесс, установив при этом код его завершения. После выполнения каких--либо действий трассировщик может завершить отлаживаемый процесс или продолжить его исполнение.

%Объявление ptrace() представлено в листинге \ref{code:ptrace}.

%\begin{lstlisting}[label=code:ptrace,caption=Функция ptrace]
%#include <sys/ptrace.h>

%long  int ptrace(enum __ptrace_request request, pid_t pid, void * addr, void * data)
%\end{lstlisting}

%Вызову передаются четыре аргумента, где \textit{request} определяет что необходимо сделать, \textit{pid} --- идентификатор трассируемого процесса, \textit{addr} --- смещение в пользовательском пространстве трассируемого процесса, откуда будет прочитано слово данных и возвращено в качестве результата работы вызова.

% Родительский процесс может породить дочерний процесс и выполнять его трассировку посредством вызова ptrace с аргументом request, имеющим значение PTRACE\_TRACEME. Процесс--трассировщик может выполнять трассировку уже существующего процесса, используя значение PTRACE\_ATTACH.


\subsection{Сравнительный анализ способов перехвата}

Результаты сравнения различных способов перехвата функций ядра представлены в таблице \ref{tbl:compare}

\clearpage

\begin{table}[h]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{\label{tbl:compare} Результаты сравнения}
			\begin{tabular}{|p{2.9cm}|p{3cm}|p{3cm}|p{3cm}|p{3.2cm}|}
				\hline
				Способ перехвата & Необходимость перекомпиляции ядра & Возможность перехвата любых обработчиков & Доступ к аргументам функции через переменные & Необходимость обхода защиты от модификации регионов памяти\\  \hline
				Linux Security API & да & нет & да &  нет \\ \hline 
				Модификация таблиц системных вызовов & нет & нет & да  & да \\ \hline 
				kprobes & нет & да & нет & нет  \\ \hline 
				Сплайсинг & нет & да& да &  да \\ \hline 
				ftrace & нет & да & да & нет \\ \hline 
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}


\section{Перехватываемые функции ядра}

% К операциям файлового ввода--вывода относятся открытие файла, чтение из файла, запись в файл и так далее. 

% Все открытые файлы представлены в ядре файловыми дескрипторами. Когда процесс открывает существующий файл или создает новый, ядро возвращает ему файловый дескриптор \cite{stiven}.

%В соответствии с принятыми соглашениями командные оболочки UNIX ассоциируют файловый дескриптор 0 со стандартным устройством ввода процесса, 1 --- со стандартным устройством вывода и 2 --- со стандартным устройством вывода сообщений об ошибках.

\subsection{Функция getdents64}

Для того, чтобы скрыть файл необходимо перехватить функцию ядра getdents64, так как она возвращает записи каталога. 
\begin{lstlisting}[label=code:getdents64,caption=Функции getdents64]
#include <fcntl.h>
	
int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);
\end{lstlisting}

Системный вызов getdents64 читает несколько структур linux\_dirent64 из каталога, на который указывает открытый файловый дескриптор fd, в буфер, указанный в dirp. В аргументе count задается размер этого буфера.

Структура linux\_dirent64 определена следующим образом:
\clearpage
\begin{lstlisting}[label=code:linuxdirent64,caption=Структура linux\_dirent64]
struct linux_dirent64 {
		ino64_t		d_ino;
		off64_t		d_off;    
		unsigned short	d_reclen; 
		unsigned char	d_type;  
		char	d_name[]; 
};
\end{lstlisting}

В d\_ino указан номер inode. В d\_off задается расстояние от начала каталога до начала следующей linux\_dirent64. В d\_reclen указывается размер данного linux\_dirent64. В d\_name задается имя файла, в d\_type --- тип файла.
 
Таким образом, перехват системного вызова getdents64 позволяет удалить запись из списка записей каталога.

\subsection{Функция unlink}

Удаление записей из каталога производится с помощью функции unlink.

\begin{lstlisting}[label=code:unlink,caption=Функция unlink]
#include <unistd.h>

int unlink(const char *pathname);
\end{lstlisting}

Эта функция удаляет запись из файла каталога и уменьшает значение счетчика ссылок на файл pathname. Если на файл указывает несколько ссылок, то его содержимое будет через них по--прежнему доступно.

Таким образом, для того, чтобы запретить удаление файла, необходимо перехватить системный вызов unlink.



\subsection{Функции open, write, read}

Запись в файл осуществляется при помощи системного вызова  write, чтение из файла --- read.
\begin{lstlisting}[label=code:read_write,caption=Функции write и read]
#include <fcntl.h>

ssize_t write(int fd, const void *buf, size_t size);
ssize_t read(int fd, void *buf, size_t count);
\end{lstlisting}

Функции write и read не позволяют получить имя файла, так как они работают только с файловым дескриптором. Однако для того, чтобы определить, можно ли выполнить операцию с файлом, необходимо знать его имя. Тогда следует перехватить функцию open, которая позволяет получить имя файла.

Системный вызов open осуществляет открытие файла.

\begin{lstlisting}[label=code:open,caption=Функции open и write]
#include <fcntl.h>
	
int open(int dirfd, const char *pathname, int flags);
int open(int dirfd, const char *pathname, int flags, mode_t mode);
\end{lstlisting}

При перехвате open необходимо сохранить идентификатор процесса, открывающего файл. Затем при перехвате write и read ориентироваться не на имя файла, а на идентификатор процесса и файловый дескриптор.

Таким образом, для того, чтобы запретить чтение из файла и запись в него, необходимо перехватить системные вызовы open, write и read.

%Функция open гарантирует, что возвращаемый ею дескриптор файла будет представлять собой наименьшее не используемое в качестве дескриптора положительное число.



%\subsection{Функция write}

%Запись данных в открытый файл производится с помощью функции write.

%\begin{lstlisting}[label=code:write,caption=Функция write]
%#include <unistd.h>
	
%ssize_t write(int fd, const void *buf, size_t size);
%\end{lstlisting}

%Возвращаемое значение обычно совпадает со значением аргумента size, в противном случае возвращается признак ошибки.

%Для обычных файлов запись начинается с текущей позиции файла. Если при открытии файла был указан флаг O\_APPEND, текущая позиция устанавливается в конец файла перед началом каждой операции записи.


%\subsection{Функция getdents}

%Функция getdents возвращает записи каталога.

%\begin{lstlisting}[label=code:getdents64,caption=Функция getdents64]
%#include <unistd.h>
	
%int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count);
%\end{lstlisting}



\section*{Вывод}

В результате сравнительного анализа выбран способ перехвата функций ядра --- ftrace, так как он позволяет перехватывать любые функции ядра и не требует его перекомпиляции.
Для сокрытия файла необходимо перехватить функцию getdents64, для запрета чтения из файла и записи в файл --- функции open, read и write, удаления --- unlink().